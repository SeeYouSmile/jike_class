Week04 作业

1.（选做）把示例代码，运行一遍，思考课上相关的问题。也可以做一些比较。

WaitAndNotify这个生产消费的模型，是否可以用LockSupport来指定接触某个线程的等待状态，
比如有很多生产者和消费者的情况，无需在生产满时去唤醒其它生产者，只需要唤醒消费者即可，
消费者同理。

conc0302.atmoic里面的几个例子，我刚开始运行觉得奇怪，怎么会小于设定的数量，明明线程安全的。
结果我想到是不是时间不够算，结果真的是，醉了。
这里可以比较出使用CAS的AtomicLong和使用分段计算的LongAdder的效率明显比使用可重入锁的效率高。

conc0302.lock.LockMain，2个线程的方法都需要获得2个锁才能进行，在每个线程获取到一个锁后进行等待，
导致都无法获取到另一个在对方手上的锁造成死锁，设计的时候要避免这种情况。

conc0302.lock.ConditionTest，对ConditionDemo进行了实验，使用2个put线程，2个take线程，
因为是只唤醒对手（put的对手是take，反之）线程，所以把每个方法中while处的判度换成if也不会有问题。

2.（必做）思考有多少种方式，在 main 函数启动一个新线程，运行一个方法，拿到这
个方法的返回值后，退出主线程? 写出你的方法，越多越好，提交到 GitHub。
一个简单的代码参考:  https://github.com/kimmking/JavaCourseCodes/tree/main/03concurrency/0301 /src/main/java/java0/conc0303/Homework03.java

work包下的Stop*

3.（选做）列举常用的并发操作 API 和工具类，简单分析其使用场景和优缺点。

Collections：
可以对List、Map、Set等集合强制加上同步操作，但是在使用迭代器和forEach循环（也是使用了迭代器）时依然需要加锁否则会有安全问题

LockSupport：
可以对线程进行阻塞和唤醒，可以用于生产消费的模式，
生产者生产完产品后唤醒所有消费者来消费，当生产的产品到达库存上限时阻塞自己，
消费者消费完产品后唤醒所有生产者来生产，当消费者消费完所有库存后阻塞自己。

AtomicInteger：
原子计数类，可用于多线程场景来计数，比如视频的播放量

LongAdder：
比Atomic类效率更高的存在，使用分段的形式，使所有的线程可以同时写，最后求和就行

4.（选做）请思考: 什么是并发? 什么是高并发? 实现高并发高可用系统需要考虑哪些 因素，对于这些你是怎么理解的?

并发：在一定的时间内处理多个事件，简单来说就是你在干活，突然有新的活来，
这时你可以马上放下手上的工作着手新的活，等新活干完再回头干刚才每干完的活。
高并发：在一定事件内处理大量事件。
实现高并发高可用系统需要考虑虑响应时间、吞吐量、并发用户数等因素。
缩短响应时间可以添加缓存，对于要涉及数据库的情况，如果数据库数据很多的情况下可以合理增加索引或者分表，
对某些场景采用NoSQL的方案进行代替。
增加吞吐量可以采用异步多线程执行的方式。
提高并发用户数可以减小锁的颗粒度。

5.（选做）请思考: 还有哪些跟并发类似 / 有关的场景和问题，有哪些可以借鉴的解决 办法。

秒杀场景：
1、限流：增加校验，识别真实用户的请求，防止恶意请求；使用令牌桶算法。
2、缓存：热点数据添加缓存。
3、异步：抢单成功与否立即返回，之后可以通过消息队列异步处理后续的步骤。
4、分流：通过部署集群服务器，通过负载均衡分散客户的请求压力。

6.（必做）把多线程和并发相关知识梳理一遍，画一个脑图，截图上传到 GitHub 上。 可选工具:xmind，百度脑图，wps，MindManage，或其他。

在resources下